<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="SHR_8PLE" Id="{550a7450-9433-423d-a33c-521fe008dca8}" SpecialFunc="None">
    <Declaration><![CDATA[(*
version 1.0	4 aug 2006
programmer 	hugo
tested by	oscat

8 bit shift register with reset and parallel load
the register can shift up or down
it also has a serial input.
the Din input is on Bit0 for up shift and on bit 7 for down shift
the Dout output is on Bit7 for up shift and on bit 0 for down shift
parallel clock is performed clock synchronous while a shift is performed first and then the register is reloaded

*)
FUNCTION_BLOCK SHR_8PLE
VAR_INPUT
	Din : BOOL;
	Dload : BYTE;
	CLK: BOOL;
	UP: BOOL :=1;
	load : BOOL;
	RST: BOOL;
END_VAR
VAR_OUTPUT
	DOut: BOOL;
END_VAR
VAR
	edge : BOOL :=1;
	register : BYTE;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* edge detection clk goes high and edge was high, reset is not active and set is not active *)
IF CLK AND edge AND NOT rst THEN
	edge := FALSE;	(* edge was detected and further edge detection is prevented until edge is true again *)
	(* here is the code for the edge event *)
	IF UP THEN						(* shift up *)
		register := SHL(register,1);
		register.0 := Din;
		Dout := register.7;
	ELSE								(* shift down *);
		register := SHR(register,1);
		register.7 := Din;
		Dout := register.0;
	END_IF;
	IF load THEN							(* the byte on Din will be loaded if load = true *)
		register := Dload;
		IF up THEN Dout := register.7; ELSE Dout := register.0; END_IF;
	END_IF;
END_IF;
IF NOT clk THEN edge := TRUE; END_IF;	(* as soon as clk goes low again, wait for next edge *)
IF rst THEN									(* if reset is active then reset output *)
	register := 0;
	Dout := FALSE;
END_IF;
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>