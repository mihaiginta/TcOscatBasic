<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="REAL_TO_FRAC" Id="{f7eaaace-fb42-42c1-a3af-3f65a7d4e137}" SpecialFunc="None">
    <Declaration><![CDATA[(* value to be converted into a fraction *)
FUNCTION REAL_TO_FRAC : FRACTION
VAR_INPUT
	X : REAL;					
	N : INT;					(* maximum size of denominator *)
END_VAR
VAR
	temp : DINT;				(* marker for calculations *)

	sign: BOOL;					(* sign of the input value *)
	X_gerundet: DINT;			(* value of fraction, rounded to integer *)
	X_ohne_Nachkomma: REAL;		(* value of fraction, without decimal places *)
	Numerator:       DINT := 1;	(* initial value numerator  *)
	Denominator:     DINT := 0;	(* initial value denominator *)
	Numerator_old:   DINT := 0;	(* initial value numerator of last calculation  *)
	Denominator_old: DINT := 1;	(* initial value denominator of last calculation   *)

END_VAR

(*
version 1.1		06. apr. 2011
programmer 	alexander
tested by		hugo

this function calculates the closest fraction for a real number

*)
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF X < 0.0 THEN
	sign := TRUE;								(* remember sign *)
	X := ABS(X);								(* calculate absolute value *)
END_IF;

REPEAT
	X_gerundet := REAL_TO_DINT(X);

	(* calculate numerator *)
	temp := numerator * X_gerundet + numerator_old;		(* extend numerator by integer part *)
	numerator_old := numerator;							(* store numerator of last calculation *)
	numerator := temp;									(* store numerator of this calculation *)

	(* calculate denominator *)
	temp := denominator * X_gerundet + denominator_old;	(* extend denominator by integer part *)
	denominator_old := denominator;						(* store denominator of last calculation *)
	denominator := temp;								(* store denominator of this calculation *)

	(* calculate remainder *)
	X_ohne_Nachkomma := DINT_TO_REAL(X_gerundet);
	IF X = X_ohne_Nachkomma THEN						(* fraction is exact *)
		IF ABS(denominator) <= N THEN						(* no rounding error *)
			numerator_old := numerator;					(* numerator_old is returned by function *)
			denominator_old := denominator;			(* denominator_old is returned by function *)
		END_IF
		EXIT;											(* no further calculation necessary *)
	ELSE
		X := 1.0 / (X - X_ohne_Nachkomma);				(* reciprocal of remainder -> new fraction *)
	END_IF

UNTIL
	ABS(Denominator) > N
END_REPEAT

(* correct sign if X was negative *)
IF sign THEN
	REAL_TO_FRAC.NUMERATOR := -1 * ABS(DINT_TO_INT(numerator_old));
ELSE
	REAL_TO_FRAC.NUMERATOR :=  ABS(DINT_TO_INT(numerator_old));
END_IF
REAL_TO_FRAC.DENOMINATOR := ABS(DINT_TO_INT(denominator_old));


(* revision history
hm		19. jan. 2011	rev 1.0
	original version

ad		06. apr. 2011	rev 1.1
	optimized code
*)]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>