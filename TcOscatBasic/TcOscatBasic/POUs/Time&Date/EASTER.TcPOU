<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="EASTER" Id="{409ba679-1bda-4fea-81e3-b404676bc144}" SpecialFunc="None">
    <Declaration><![CDATA[(*
version 1.3	7. apr. 2008
programmer 	hugo
tested by	tobias

easter calculates the day of easter sunday for a given year.
most other catholic holidays are calculated in reference to easter sunday.

*)
FUNCTION EASTER : DATE
VAR_INPUT
	year : INT;
END_VAR
VAR
	b,c: INT;
	oday: INT;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[b := (204 - 11 * (YEAR MOD 19)) MOD 30;
IF b > 27 THEN b := b - 1; END_IF;
c := (year + SHR(year,2) + b - 13) MOD 7;
oday := 28 + b - c;
IF oday > 33 THEN
	EASTER := SET_DATE(year, 4, oday - 31);
ELSE
	EASTER := SET_DATE(year, 3, oday);
END_IF;




(* alternative algorithm via the Passover festival
execution time roughly 200us
The so-called Passover full moon is calculated by dividing the year by 19,
and the remainder is compared with the following table:

    0: Apr 14       5: Apr 18      10: Mar 25      15: Mar 30
    1: Apr 03       6: Apr 08      11: Apr 13      16: Apr 17
    2: Mar 23       7: Mar 28      12: Apr 02      17: Apr 07
    3: Apr 11       8: Apr 16      13: Mar 22      18: Mar 27
    4: Mar 31       9: Apr 05      14: Apr 10

If this date falls on a Sunday, Easter is the next Sunday!

Example: 1992 MOD 19 = 16, which results in 17.04., the next Sunday
         is then April 19 (Easter Sunday)
*)


(* this algorithm is 180 us
a := year MOD 19;
b := year / 100;
c := year MOD 100;
d := b / 4;
e := b MOD 4;
f := (b + 8) / 25;
g := (b - f + 1) / 3;
h := (19 * a + b - d -g + 15) MOD 30;
i := C / 4;
k := c MOD 4;
l := (32 + 2*e + 2*i - h - k) MOD 7;
m := (a + 11 * h + 22 * l) / 451;
x := h + l - 7 * m + 114;
n := X / 31;
o := x MOD 31 + 1;

easter := set_Date(year,n,o);
*)
(* 
In the magazine "Nature" from April 20, 1876, an anonymous author published a table with rules for calculating the (Gregorian) Easter Sunday of year J. Expressed in formulas, the following is obtained:
a	=	J mod 19
b	=	int(J / 100)
c	=	J mod 100
d	=	int(b / 4)
e	=	b mod 4
f	=	int((b + 8) / 25)
g	=	int((b - f + 1) / 3
h	=	(19 · a + b - d - g + 15) mod 30
i	=	int(c / 4)
k	=	c mod 4
l	=	(32 + 2 · e + 2 · i - h - k) mod 7
m	=	int((a + 11 · h + 22 · l) / 451)
n	=	int((h + l - 7 · m + 114) / 31)
o	=	(h + l - 7 · m + 114) mod 31

n is the number of the month, o + 1 the number of the day on which Easter Sunday falls in year J. This algorithm does not require auxiliary numbers.
*)

(* revision history
hm	27. dec 2006	rev 1.0
	original version

hm	15. dec 2007	rev 1.1
	modified code for better performance

hm	3. feb 2008		rev 1.2
	modified code for better performance

hm	7. apr. 2008	rev 1.3
	improved performance
*)]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>